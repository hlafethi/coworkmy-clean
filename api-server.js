import express from 'express';
import cors from 'cors';
import { Pool } from 'pg';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import crypto from 'crypto';
import Stripe from 'stripe';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
const PORT = process.env.PORT || 5000;

// Configuration de la base de donn√©es
const pool = new Pool({
  user: process.env.VITE_DATABASE_USER || process.env.DB_USER || 'vpshostinger',
  host: process.env.VITE_DATABASE_HOST || process.env.DB_HOST || '147.93.58.155',
  database: process.env.VITE_DATABASE_NAME || process.env.DB_NAME || 'coworkmy',
  password: process.env.VITE_DATABASE_PASSWORD || process.env.DB_PASSWORD || 'Fethi@2025!',
  port: process.env.VITE_DATABASE_PORT || process.env.DB_PORT || 5432,
  ssl: process.env.VITE_DATABASE_SSL === 'true' ? { rejectUnauthorized: false } : false,
});

// Middleware
app.use(cors());
app.use(express.json({ limit: '50mb' })); // Augmenter la limite pour les images
app.use(express.urlencoded({ extended: true, limit: '50mb' }));

// Initialisation de la base de donn√©es
async function initializeDatabase() {
  try {
    console.log('üîß Initialisation de la base de donn√©es...');
    
    // V√©rifier la structure de la table profiles
    const tableInfo = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'profiles'
    `);
    
    console.log('üìã Structure actuelle de la table profiles:', tableInfo.rows);
    
    // Ajouter les colonnes manquantes si elles n'existent pas
    const columns = tableInfo.rows.map(row => row.column_name);
    
    if (!columns.includes('password_hash')) {
      console.log('‚ûï Ajout de la colonne password_hash...');
      await pool.query('ALTER TABLE profiles ADD COLUMN password_hash VARCHAR(255)');
    }
    
    if (!columns.includes('full_name')) {
      console.log('‚ûï Ajout de la colonne full_name...');
      await pool.query('ALTER TABLE profiles ADD COLUMN full_name VARCHAR(255)');
    }
    
    if (!columns.includes('is_admin')) {
      console.log('‚ûï Ajout de la colonne is_admin...');
      await pool.query('ALTER TABLE profiles ADD COLUMN is_admin BOOLEAN DEFAULT FALSE');
    }

    // Cr√©ation de la table support_tickets si elle n'existe pas
    await pool.query(`
      CREATE TABLE IF NOT EXISTS support_tickets (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        user_id UUID REFERENCES profiles(id),
        subject VARCHAR(500) NOT NULL,
        message TEXT NOT NULL,
        priority VARCHAR(20) DEFAULT 'medium',
        status VARCHAR(20) DEFAULT 'open',
        created_at TIMESTAMP DEFAULT NOW(),
        updated_at TIMESTAMP DEFAULT NOW()
      )
    `);

    // Cr√©ation de la table support_ticket_responses si elle n'existe pas
    await pool.query(`
      CREATE TABLE IF NOT EXISTS support_ticket_responses (
        id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
        ticket_id UUID REFERENCES support_tickets(id),
        user_id UUID REFERENCES profiles(id),
        message TEXT NOT NULL,
        is_admin BOOLEAN DEFAULT FALSE,
        created_at TIMESTAMP DEFAULT NOW()
      )
    `);

    console.log('‚úÖ Base de donn√©es initialis√©e avec succ√®s');
  } catch (error) {
    console.error('‚ùå Erreur initialisation base de donn√©es:', error);
  }
}

// Initialiser la base de donn√©es au d√©marrage
initializeDatabase();

// Middleware d'authentification
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) {
    return res.status(401).json({ success: false, error: 'Token d\'acc√®s requis' });
  }

  jwt.verify(token, process.env.JWT_SECRET || 'your-secret-key', (err, user) => {
    if (err) {
      return res.status(403).json({ success: false, error: 'Token invalide' });
    }
    req.user = user;
    next();
  });
};

// Route de test
app.get('/api/health', (req, res) => {
  res.json({ status: 'OK', message: 'API CoworkMy fonctionne' });
});

// Endpoint de test simple sans base de donn√©es
app.get('/api/test-simple', (req, res) => {
  res.json({ status: 'OK', message: 'Test simple r√©ussi', timestamp: new Date().toISOString() });
});

// Endpoints d'authentification
app.get('/api/auth/me', (req, res) => {
  res.json({ 
    success: true, 
    user: null,
    message: 'Aucun utilisateur connect√©' 
  });
});

// Endpoint de connexion
app.post('/api/auth/signin', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    console.log('üîê Tentative de connexion pour:', email);
    
    if (!email || !password) {
      console.log('‚ùå Email ou mot de passe manquant');
      return res.status(400).json({ 
        success: false, 
        error: 'Email et mot de passe requis' 
      });
    }

    // Recherche de l'utilisateur dans la base de donn√©es
    console.log('üîç Recherche de l\'utilisateur dans la base de donn√©es...');
    const userResult = await pool.query(
      'SELECT id, email, password_hash, full_name, is_admin FROM profiles WHERE email = $1',
      [email]
    );

    console.log('üìä Nombre d\'utilisateurs trouv√©s:', userResult.rows.length);

    if (userResult.rows.length === 0) {
      console.log('‚ùå Aucun utilisateur trouv√© avec cet email');
      return res.status(401).json({ 
        success: false, 
        error: 'Email ou mot de passe incorrect' 
      });
    }

    const user = userResult.rows[0];
    console.log('üë§ Utilisateur trouv√©:', user.email, 'Admin:', user.is_admin);

    // V√©rification du mot de passe
    console.log('üîí V√©rification du mot de passe...');
    const isValidPassword = await bcrypt.compare(password, user.password_hash);
    
    if (!isValidPassword) {
      console.log('‚ùå Mot de passe incorrect');
      return res.status(401).json({ 
        success: false, 
        error: 'Email ou mot de passe incorrect' 
      });
    }

    console.log('‚úÖ Mot de passe correct');

    // G√©n√©ration du token JWT
    const token = jwt.sign(
      { 
        userId: user.id, 
        email: user.email,
        isAdmin: user.is_admin 
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '24h' }
    );

    console.log('üé´ Token JWT g√©n√©r√© pour:', user.email);

    res.json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          full_name: user.full_name,
          is_admin: user.is_admin
        },
        token
      },
      message: 'Connexion r√©ussie'
    });

  } catch (error) {
    console.error('‚ùå Erreur connexion:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur interne du serveur' 
    });
  }
});

// Endpoint d'inscription
app.post('/api/auth/signup', async (req, res) => {
  try {
    const { email, password, full_name } = req.body;
    
    if (!email || !password || !full_name) {
      return res.status(400).json({ 
        success: false, 
        error: 'Email, mot de passe et nom requis' 
      });
    }

    // V√©rification si l'utilisateur existe d√©j√†
    const existingUser = await pool.query(
      'SELECT id FROM profiles WHERE email = $1',
      [email]
    );

    if (existingUser.rows.length > 0) {
      return res.status(409).json({ 
        success: false, 
        error: 'Un utilisateur avec cet email existe d√©j√†' 
      });
    }

    // Hashage du mot de passe
    const passwordHash = await bcrypt.hash(password, 10);

    // Cr√©ation de l'utilisateur
    const newUser = await pool.query(
      'INSERT INTO profiles (id, email, password_hash, full_name, is_admin, created_at) VALUES ($1, $2, $3, $4, $5, NOW()) RETURNING id, email, full_name, is_admin',
      [crypto.randomUUID(), email, passwordHash, full_name, false]
    );

    const user = newUser.rows[0];

    // G√©n√©ration du token JWT
    const token = jwt.sign(
      { 
        userId: user.id, 
        email: user.email,
        isAdmin: user.is_admin 
      },
      process.env.JWT_SECRET || 'your-secret-key',
      { expiresIn: '24h' }
    );

    res.status(201).json({
      success: true,
      data: {
        user: {
          id: user.id,
          email: user.email,
          full_name: user.full_name,
          is_admin: user.is_admin
        },
        token
      },
      message: 'Inscription r√©ussie'
    });

  } catch (error) {
    console.error('Erreur inscription:', error);
    res.status(500).json({ 
      success: false, 
      error: 'Erreur interne du serveur' 
    });
  }
});

// Endpoints pour les espaces
app.get('/api/spaces', async (req, res) => {
  try {
    console.log('üè¢ GET /api/spaces - R√©cup√©ration des espaces...');
    
    // V√©rifier que la table spaces existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'spaces'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üìã Table spaces n\'existe pas encore');
      res.json({ 
        success: true, 
        data: [],
        message: 'Aucun espace disponible' 
      });
      return;
    }
    
    // R√©cup√©rer tous les espaces (actifs et inactifs)
    const result = await pool.query(`
      SELECT * FROM spaces 
      ORDER BY created_at DESC
    `);
    
    console.log(`‚úÖ ${result.rows.length} espaces trouv√©s`);
    res.json({ 
      success: true, 
      data: result.rows,
      message: result.rows.length > 0 ? `${result.rows.length} espaces disponibles` : 'Aucun espace disponible'
    });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration espaces:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint supprim√© - remplac√© par l'endpoint dynamique plus bas

// Endpoint supprim√© - remplac√© par l'endpoint dynamique plus bas

// Endpoint de test de base de donn√©es
app.get('/api/test-db', async (req, res) => {
  try {
    const result = await pool.query('SELECT NOW() as current_time');
    res.json({ status: 'OK', db_time: result.rows[0].current_time });
  } catch (error) {
    console.error('‚ùå Erreur test DB:', error);
    res.status(500).json({ status: 'ERROR', error: error.message });
  }
});

// Endpoint de test simple sans base de donn√©es
app.get('/api/test-simple', (req, res) => {
  res.json({ status: 'OK', message: 'Test simple r√©ussi', timestamp: new Date().toISOString() });
});

// ===== ENDPOINTS DE TICKETS DE SUPPORT =====

// R√©cup√©rer les tickets de l'utilisateur
app.get('/api/support/tickets', authenticateToken, async (req, res) => {
  try {
    console.log('üîç GET /api/support/tickets - R√©cup√©ration des tickets...');
    console.log('üë§ User ID:', req.user.id);
    
    const result = await pool.query(
      `SELECT * FROM support_tickets
       WHERE user_id = $1
       ORDER BY created_at DESC`,
      [req.user.id]
    );
    
    console.log(`‚úÖ ${result.rows.length} tickets trouv√©s`);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration tickets:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// Cr√©er un ticket
app.post('/api/support/tickets', authenticateToken, async (req, res) => {
  try {
    const { subject, message, priority = 'medium' } = req.body;
    console.log('üîç POST /api/support/tickets - Cr√©ation d\'un ticket...');
    console.log('üë§ User ID:', req.user.id);
    console.log('üìä Donn√©es:', { subject, message, priority });
    
    // V√©rifier si la table existe, sinon la cr√©er
    try {
      await pool.query('SELECT 1 FROM support_tickets LIMIT 1');
    } catch (tableError) {
      if (tableError.code === '42P01') {
        console.log('üìù Cr√©ation de la table support_tickets...');
        await pool.query(`
          CREATE TABLE IF NOT EXISTS support_tickets (
            id VARCHAR(36) PRIMARY KEY,
            user_id VARCHAR(36) NOT NULL,
            subject VARCHAR(255) NOT NULL,
            message TEXT NOT NULL,
            priority VARCHAR(20) DEFAULT 'medium',
            status VARCHAR(20) DEFAULT 'open',
            created_at TIMESTAMP DEFAULT NOW(),
            updated_at TIMESTAMP DEFAULT NOW()
          )
        `);
        console.log('‚úÖ Table support_tickets cr√©√©e');
      } else {
        throw tableError;
      }
    }
    
    // G√©n√©rer un UUID c√¥t√© application
    const ticketId = crypto.randomUUID();
    
    const result = await pool.query(
      `INSERT INTO support_tickets (id, user_id, subject, message, priority, status, created_at)
       VALUES ($1, $2, $3, $4, $5, 'open', NOW())
       RETURNING *`,
      [ticketId, req.user.id, subject, message, priority]
    );
    
    console.log(`‚úÖ Ticket cr√©√©:`, result.rows[0]);
    res.status(201).json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation ticket:', error);
    console.error('‚ùå D√©tails erreur:', error.message);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({ success: false, error: 'Erreur serveur interne' });
  }
});

// R√©cup√©rer les r√©ponses d'un ticket
app.get('/api/support/tickets/:id/responses', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    console.log(`üîç GET /api/support/tickets/${id}/responses - R√©cup√©ration des r√©ponses...`);
    console.log('üë§ User ID:', req.user.id);
    
    const result = await pool.query(
      `SELECT * FROM support_ticket_responses 
       WHERE ticket_id = $1 
       ORDER BY created_at ASC`,
      [id]
    );
    
    console.log(`‚úÖ ${result.rows.length} r√©ponses trouv√©es pour le ticket ${id}`);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration r√©ponses ticket:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// Ajouter une r√©ponse √† un ticket
app.post('/api/support/tickets/:id/responses', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { message, is_admin_response } = req.body;
    console.log(`üîç POST /api/support/tickets/${id}/responses - Ajout d'une r√©ponse...`);
    console.log('üë§ User ID:', req.user.id);
    console.log('üìä Donn√©es:', { message, is_admin_response });
    
    const result = await pool.query(
      `INSERT INTO support_ticket_responses (ticket_id, user_id, message, is_admin_response, created_at)
       VALUES ($1, $2, $3, $4, NOW())
       RETURNING *`,
      [id, req.user.id, message, is_admin_response || false]
    );
    
    console.log(`‚úÖ R√©ponse ajout√©e au ticket ${id}:`, result.rows[0]);
    res.status(201).json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur ajout r√©ponse ticket:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// ===== ENDPOINTS ADMIN DE TICKETS =====

// R√©cup√©rer tous les tickets (admin)
app.get('/api/admin/support/tickets', authenticateToken, async (req, res) => {
  try {
    console.log('üîç GET /api/admin/support/tickets - R√©cup√©ration des tickets admin...');
    console.log('üë§ User ID:', req.user.id);
    
    // V√©rifier si l'utilisateur est admin
    const userCheck = await pool.query(
      'SELECT is_admin FROM profiles WHERE id = $1',
      [req.user.id]
    );
    
    if (!userCheck.rows[0]?.is_admin) {
      return res.status(403).json({ success: false, error: 'Acc√®s refus√© - Admin requis' });
    }
    
    const result = await pool.query(
      `SELECT st.*, p.full_name as user_name, p.email as user_email
       FROM support_tickets st
       JOIN profiles p ON st.user_id = p.id
       ORDER BY st.created_at DESC`
    );
    
    console.log(`‚úÖ ${result.rows.length} tickets admin trouv√©s`);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration tickets admin:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// R√©cup√©rer les r√©ponses d'un ticket (admin)
app.get('/api/admin/support/tickets/:id/responses', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    console.log('üîç R√©cup√©ration des r√©ponses pour ticket:', id);
    
    const result = await pool.query(
      'SELECT * FROM support_ticket_responses WHERE ticket_id = $1 ORDER BY created_at ASC',
      [id]
    );
    
    console.log('‚úÖ R√©ponses r√©cup√©r√©es:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration r√©ponses:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// Ajouter une r√©ponse admin √† un ticket
app.post('/api/admin/support/tickets/:id/responses', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { message } = req.body;
    console.log('üîç Ajout r√©ponse pour ticket:', id);
    
    const responseId = crypto.randomUUID();
    const result = await pool.query(
      'INSERT INTO support_ticket_responses (id, ticket_id, user_id, message, is_admin, created_at) VALUES ($1, $2, $3, $4, true, NOW()) RETURNING *',
      [responseId, id, req.user.id, message]
    );
    
    console.log('‚úÖ R√©ponse admin ajout√©e:', result.rows[0]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur ajout r√©ponse admin:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// Mettre √† jour le statut d'un ticket
app.put('/api/admin/support/tickets/:id/status', authenticateToken, async (req, res) => {
  try {
    const { id } = req.params;
    const { status } = req.body;
    console.log('üîç Mise √† jour statut ticket:', id, '->', status);
    
    const result = await pool.query(
      'UPDATE support_tickets SET status = $1, updated_at = NOW() WHERE id = $2 RETURNING *',
      [status, id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Ticket non trouv√©' });
    }
    
    console.log('‚úÖ Statut ticket mis √† jour:', result.rows[0]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur mise √† jour statut:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// ===== ENDPOINTS TEMPORAIRES SANS AUTHENTIFICATION =====

// Cr√©er un ticket utilisateur (sans auth)
app.post('/api/support/tickets-user-no-auth', async (req, res) => {
  try {
    const { subject, message, priority = 'medium' } = req.body;
    console.log('üîç Cr√©ation ticket utilisateur (sans auth)...');
    console.log('üìä Donn√©es:', { subject, message, priority });
    
    // V√©rifier si la table existe, sinon la cr√©er
    try {
      await pool.query('SELECT 1 FROM support_tickets LIMIT 1');
    } catch (tableError) {
      if (tableError.code === '42P01') {
        console.log('üìù Cr√©ation de la table support_tickets...');
        await pool.query(`
          CREATE TABLE IF NOT EXISTS support_tickets (
            id VARCHAR(36) PRIMARY KEY,
            user_id VARCHAR(36) NOT NULL,
            subject VARCHAR(255) NOT NULL,
            message TEXT NOT NULL,
            priority VARCHAR(20) DEFAULT 'medium',
            status VARCHAR(20) DEFAULT 'open',
            created_at TIMESTAMP DEFAULT NOW(),
            updated_at TIMESTAMP DEFAULT NOW()
          )
        `);
        console.log('‚úÖ Table support_tickets cr√©√©e');
      } else {
        throw tableError;
      }
    }
    
    // G√©n√©rer UUID c√¥t√© application
    const ticketId = crypto.randomUUID();
    const userId = 'f6682b18-7d10-4016-be08-885e989cffca'; // ID utilisateur fixe pour le test
    
    console.log('üìù UUID g√©n√©r√©:', ticketId);
    console.log('üë§ User ID utilis√©:', userId);
    
    const result = await pool.query(
      `INSERT INTO support_tickets (id, user_id, subject, message, priority, status, created_at, updated_at)
       VALUES ($1, $2, $3, $4, $5, 'open', NOW(), NOW())
       RETURNING *`,
      [ticketId, userId, subject, message, priority]
    );
    
    console.log('‚úÖ Ticket utilisateur cr√©√©:', result.rows[0]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation ticket utilisateur:', error);
    console.error('‚ùå D√©tails erreur:', error.message);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({ success: false, error: error.message });
  }
});

// R√©cup√©rer les tickets admin (sans auth)
app.get('/api/admin/support/tickets-no-auth', async (req, res) => {
  try {
    console.log('üîç R√©cup√©ration des tickets admin (sans auth)...');
    
    const result = await pool.query(
      `SELECT st.*, p.full_name as user_name, p.email as user_email
       FROM support_tickets st
       JOIN profiles p ON st.user_id = p.id
       ORDER BY st.created_at DESC`
    );
    
    console.log(`‚úÖ ${result.rows.length} tickets admin trouv√©s`);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration tickets admin:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// R√©cup√©rer les r√©ponses d'un ticket utilisateur (sans auth)
app.get('/api/support/tickets/:id/responses-user-no-auth', async (req, res) => {
  try {
    const { id } = req.params;
    console.log('üîç R√©cup√©ration des r√©ponses pour ticket utilisateur (sans auth):', id);
    
    const result = await pool.query(
      `SELECT * FROM support_ticket_responses 
       WHERE ticket_id = $1 
       ORDER BY created_at ASC`,
      [id]
    );
    
    console.log('‚úÖ R√©ponses utilisateur r√©cup√©r√©es:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration r√©ponses utilisateur:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// R√©cup√©rer les r√©ponses d'un ticket admin (sans auth)
app.get('/api/admin/support/tickets/:id/responses-no-auth', async (req, res) => {
  try {
    const { id } = req.params;
    console.log('üîç R√©cup√©ration des r√©ponses pour ticket (sans auth):', id);
    
    const result = await pool.query(
      `SELECT * FROM support_ticket_responses 
       WHERE ticket_id = $1 
       ORDER BY created_at ASC`,
      [id]
    );
    
    console.log('‚úÖ R√©ponses r√©cup√©r√©es:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration r√©ponses:', error);
    res.status(500).json({ success: false, error: 'Erreur serveur' });
  }
});

// Ajouter une r√©ponse utilisateur (sans auth)
app.post('/api/support/tickets/:id/responses-user-no-auth', async (req, res) => {
  try {
    console.log('üîç Ajout r√©ponse utilisateur sans auth...');
    console.log('üìù Donn√©es re√ßues:', req.body);
    
    const { id } = req.params;
    const { message } = req.body;
    const userId = 'f6682b18-7d10-4016-be08-885e989cffca'; // ID utilisateur fixe pour le test
    
    console.log('üìù Donn√©es extraites:', { ticketId: id, message, userId });
    
    // V√©rifier si la table existe
    try {
      await pool.query('SELECT 1 FROM support_ticket_responses LIMIT 1');
      console.log('‚úÖ Table support_ticket_responses existe');
      
      // V√©rifier si la colonne is_admin existe, sinon l'ajouter
      try {
        await pool.query('SELECT is_admin FROM support_ticket_responses LIMIT 1');
        console.log('‚úÖ Colonne is_admin existe');
      } catch (columnError) {
        if (columnError.code === '42703') {
          console.log('üìù Ajout de la colonne is_admin...');
          await pool.query('ALTER TABLE support_ticket_responses ADD COLUMN is_admin BOOLEAN DEFAULT FALSE');
          console.log('‚úÖ Colonne is_admin ajout√©e');
        } else {
          throw columnError;
        }
      }
    } catch (tableError) {
      if (tableError.code === '42P01') {
        console.log('üìù Cr√©ation de la table support_ticket_responses...');
        await pool.query(`
          CREATE TABLE IF NOT EXISTS support_ticket_responses (
            id VARCHAR(36) PRIMARY KEY,
            ticket_id VARCHAR(36) NOT NULL,
            user_id VARCHAR(36) NOT NULL,
            message TEXT NOT NULL,
            is_admin BOOLEAN DEFAULT FALSE,
            created_at TIMESTAMP DEFAULT NOW()
          )
        `);
        console.log('‚úÖ Table support_ticket_responses cr√©√©e');
      } else {
        throw tableError;
      }
    }
    
    // G√©n√©rer UUID c√¥t√© application
    const responseId = crypto.randomUUID();
    console.log('üìù UUID g√©n√©r√©:', responseId);
    
    const result = await pool.query(
      `INSERT INTO support_ticket_responses (id, ticket_id, user_id, message, is_admin, created_at)
       VALUES ($1, $2, $3, $4, FALSE, NOW())
       RETURNING *`,
      [responseId, id, userId, message]
    );
    
    console.log('‚úÖ R√©ponse utilisateur ajout√©e:', result.rows[0]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur ajout r√©ponse utilisateur:', error);
    console.error('‚ùå D√©tails erreur:', error.message);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Ajouter une r√©ponse admin (sans auth)
app.post('/api/admin/support/tickets/:id/responses-no-auth', async (req, res) => {
  try {
    console.log('üîç Ajout r√©ponse admin sans auth...');
    console.log('üìù Donn√©es re√ßues:', req.body);
    
    const { id } = req.params;
    const { message } = req.body;
    const adminUserId = 'f6682b18-7d10-4016-be08-885e989cffca'; // ID utilisateur fixe pour le test (admin temporaire)
    
    console.log('üìù Donn√©es extraites:', { ticketId: id, message, adminUserId });
    
    // V√©rifier si la table existe
    try {
      await pool.query('SELECT 1 FROM support_ticket_responses LIMIT 1');
      console.log('‚úÖ Table support_ticket_responses existe');
      
      // V√©rifier si la colonne is_admin existe, sinon l'ajouter
      try {
        await pool.query('SELECT is_admin FROM support_ticket_responses LIMIT 1');
        console.log('‚úÖ Colonne is_admin existe');
      } catch (columnError) {
        if (columnError.code === '42703') {
          console.log('üìù Ajout de la colonne is_admin...');
          await pool.query('ALTER TABLE support_ticket_responses ADD COLUMN is_admin BOOLEAN DEFAULT FALSE');
          console.log('‚úÖ Colonne is_admin ajout√©e');
        } else {
          throw columnError;
        }
      }
    } catch (tableError) {
      if (tableError.code === '42P01') {
        console.log('üìù Cr√©ation de la table support_ticket_responses...');
        await pool.query(`
          CREATE TABLE IF NOT EXISTS support_ticket_responses (
            id VARCHAR(36) PRIMARY KEY,
            ticket_id VARCHAR(36) NOT NULL,
            user_id VARCHAR(36) NOT NULL,
            message TEXT NOT NULL,
            is_admin BOOLEAN DEFAULT FALSE,
            created_at TIMESTAMP DEFAULT NOW()
          )
        `);
        console.log('‚úÖ Table support_ticket_responses cr√©√©e');
      } else {
        throw tableError;
      }
    }
    
    // G√©n√©rer UUID c√¥t√© application
    const responseId = crypto.randomUUID();
    console.log('üìù UUID g√©n√©r√©:', responseId);
    
    const result = await pool.query(
      `INSERT INTO support_ticket_responses (id, ticket_id, user_id, message, is_admin, created_at)
       VALUES ($1, $2, $3, $4, TRUE, NOW())
       RETURNING *`,
      [responseId, id, adminUserId, message]
    );
    
    console.log('‚úÖ R√©ponse admin ajout√©e:', result.rows[0]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur ajout r√©ponse admin:', error);
    console.error('‚ùå D√©tails erreur:', error.message);
    console.error('‚ùå Stack trace:', error.stack);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les utilisateurs (admin)
app.get('/api/users', async (req, res) => {
  try {
    console.log('üë• R√©cup√©ration des utilisateurs...');
    
    const result = await pool.query(`
      SELECT 
        id, 
        email, 
        full_name, 
        first_name, 
        last_name,
        is_admin, 
        created_at,
        updated_at
      FROM profiles 
      ORDER BY created_at DESC
    `);
    
    console.log('‚úÖ Utilisateurs r√©cup√©r√©s:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration utilisateurs:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les r√©servations (admin)
app.get('/api/admin/bookings', async (req, res) => {
  try {
    console.log('üìÖ R√©cup√©ration des r√©servations admin...');
    
    // D'abord, v√©rifier la structure de la table bookings
    const structureResult = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'bookings' 
      ORDER BY ordinal_position
    `);
    
    console.log('üìã Structure de la table bookings:', structureResult.rows);
    
    // Requ√™te adapt√©e selon la structure r√©elle
    const result = await pool.query(`
      SELECT 
        b.*,
        p.email as user_email,
        p.full_name as user_name,
        s.name as space_name,
        s.description as space_description
      FROM bookings b
      LEFT JOIN profiles p ON b.user_id = p.id
      LEFT JOIN spaces s ON b.space_id = s.id
      ORDER BY b.created_at DESC
    `);
    
    console.log('‚úÖ R√©servations r√©cup√©r√©es:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration r√©servations:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les paiements (admin)
app.get('/api/payments', async (req, res) => {
  try {
    console.log('üí≥ R√©cup√©ration des paiements admin...');
    
    // V√©rifier la structure de la table payments
    const structureResult = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'payments' 
      ORDER BY ordinal_position
    `);
    
    console.log('üìã Structure de la table payments:', structureResult.rows);
    
    // Requ√™te adapt√©e selon la structure r√©elle
    const result = await pool.query(`
      SELECT 
        p.*,
        pr.email as user_email,
        pr.full_name as user_name,
        s.name as space_name,
        b.start_date,
        b.end_date
      FROM payments p
      LEFT JOIN bookings b ON p.booking_id = b.id
      LEFT JOIN profiles pr ON b.user_id = pr.id
      LEFT JOIN spaces s ON b.space_id = s.id
      ORDER BY p.created_at DESC
    `);
    
    console.log('‚úÖ Paiements r√©cup√©r√©s:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration paiements:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les param√®tres admin
app.get('/api/admin/settings', async (req, res) => {
  try {
    console.log('‚öôÔ∏è R√©cup√©ration des param√®tres admin...');
    
    // V√©rifier la structure de la table admin_settings
    const structureResult = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'admin_settings' 
      ORDER BY ordinal_position
    `);
    
    console.log('üìã Structure de la table admin_settings:', structureResult.rows);
    
    // R√©cup√©rer les param√®tres
    const result = await pool.query(`
      SELECT * FROM admin_settings ORDER BY created_at DESC
    `);
    
    console.log('‚úÖ Param√®tres r√©cup√©r√©s:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration param√®tres:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les cr√©neaux horaires
app.get('/api/time-slots', async (req, res) => {
  try {
    console.log('‚è∞ R√©cup√©ration des cr√©neaux horaires...');
    
    const result = await pool.query(`
      SELECT * FROM time_slots ORDER BY day_of_week, start_time
    `);
    
    console.log('‚úÖ Cr√©neaux r√©cup√©r√©s:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration cr√©neaux:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les mod√®les d'email
app.get('/api/email-templates', async (req, res) => {
  try {
    console.log('üìß R√©cup√©ration des mod√®les d\'email...');
    
    const result = await pool.query(`
      SELECT * FROM email_templates ORDER BY created_at DESC
    `);
    
    console.log('‚úÖ Mod√®les r√©cup√©r√©s:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration mod√®les:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les pages l√©gales
app.get('/api/legal-pages', async (req, res) => {
  try {
    console.log('üìÑ R√©cup√©ration des pages l√©gales...');
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'legal_pages'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üìÑ Table legal_pages n\'existe pas, retour de donn√©es par d√©faut');
      res.json({ success: true, data: [] });
      return;
    }
    
    const result = await pool.query(`
      SELECT * FROM legal_pages ORDER BY created_at DESC
    `);
    
    console.log('‚úÖ Pages r√©cup√©r√©es:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration pages:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les param√®tres de cookies
app.get('/api/cookie-settings', async (req, res) => {
  try {
    console.log('üç™ R√©cup√©ration des param√®tres cookies...');
    
    const result = await pool.query(`
      SELECT * FROM cookie_settings ORDER BY created_at DESC
    `);
    
    console.log('‚úÖ Param√®tres cookies r√©cup√©r√©s:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration cookies:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour cr√©er des pages l√©gales
app.post('/api/legal-pages', async (req, res) => {
  try {
    console.log('üìÑ Cr√©ation de pages l√©gales...');
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'legal_pages'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üìÑ Table legal_pages n\'existe pas, retour de donn√©es par d√©faut');
      const pages = Array.isArray(req.body) ? req.body : [req.body];
      res.json({ success: true, data: pages });
      return;
    }
    
    const pages = Array.isArray(req.body) ? req.body : [req.body];
    
    const result = await pool.query(`
      INSERT INTO legal_pages (type, title, content, last_updated)
      VALUES ${pages.map((_, index) => `($${index * 4 + 1}, $${index * 4 + 2}, $${index * 4 + 3}, $${index * 4 + 4})`).join(', ')}
      RETURNING *
    `, pages.flatMap(page => [page.type, page.title, page.content, page.last_updated]));
    
    console.log('‚úÖ Pages l√©gales cr√©√©es:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation pages l√©gales:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour mettre √† jour une page l√©gale
app.put('/api/legal-pages/:type', async (req, res) => {
  try {
    console.log('üìÑ Mise √† jour de la page l√©gale:', req.params.type);
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'legal_pages'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üìÑ Table legal_pages n\'existe pas, retour de donn√©es par d√©faut');
      const { title, content, last_updated } = req.body;
      res.json({ success: true, data: { type: req.params.type, title, content, last_updated } });
      return;
    }
    
    const { title, content, last_updated } = req.body;
    
    const result = await pool.query(`
      UPDATE legal_pages 
      SET title = $1, content = $2, last_updated = $3
      WHERE type = $4
      RETURNING *
    `, [title, content, last_updated, req.params.type]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Page non trouv√©e' });
    }
    
    console.log('‚úÖ Page l√©gale mise √† jour');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur mise √† jour page l√©gale:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer un utilisateur par ID
app.get('/api/users/:id', async (req, res) => {
  try {
    console.log('üë§ R√©cup√©ration de l\'utilisateur:', req.params.id);
    
    const result = await pool.query(`
      SELECT 
        id, 
        email, 
        full_name, 
        first_name, 
        last_name,
        is_admin, 
        created_at,
        updated_at,
        phone,
        company,
        city,
        avatar_url
      FROM profiles 
      WHERE id = $1
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Utilisateur non trouv√©' });
    }
    
    console.log('‚úÖ Utilisateur r√©cup√©r√©');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration utilisateur:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour mettre √† jour un utilisateur
app.put('/api/users/:id', async (req, res) => {
  try {
    console.log(`üë§ Mise √† jour de l'utilisateur: ${req.params.id}`);
    
    const updateData = req.body;
    const userId = req.params.id;
    
    // Construire la requ√™te de mise √† jour dynamiquement
    const fields = [];
    const values = [];
    let paramIndex = 1;
    
    for (const [key, value] of Object.entries(updateData)) {
      if (key !== 'id' && value !== undefined) {
        fields.push(`${key} = $${paramIndex}`);
        values.push(value);
        paramIndex++;
      }
    }
    
    if (fields.length === 0) {
      return res.status(400).json({ success: false, error: 'Aucune donn√©e √† mettre √† jour' });
    }
    
    // Ajouter updated_at
    fields.push(`updated_at = $${paramIndex}`);
    values.push(new Date().toISOString());
    paramIndex++;
    
    // Ajouter l'ID √† la fin
    values.push(userId);
    
    const query = `
      UPDATE profiles 
      SET ${fields.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING *
    `;
    
    const result = await pool.query(query, values);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Utilisateur non trouv√©' });
    }
    
    console.log('‚úÖ Utilisateur mis √† jour');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur mise √† jour utilisateur:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les documents d'un utilisateur
app.get('/api/users/:id/documents', async (req, res) => {
  try {
    console.log(`üìÑ R√©cup√©ration des documents pour l'utilisateur: ${req.params.id}`);
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'profile_documents'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('‚ö†Ô∏è Table profile_documents n\'existe pas, retour de liste vide');
      return res.json({ success: true, data: [] });
    }
    
    const result = await pool.query(`
      SELECT * FROM profile_documents 
      WHERE user_id = $1
      ORDER BY uploaded_at DESC
    `, [req.params.id]);
    
    console.log('‚úÖ Documents r√©cup√©r√©s:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration documents:', error);
    // En cas d'erreur, retourner une liste vide plut√¥t qu'une erreur
    res.json({ success: true, data: [] });
  }
});

// Endpoints pour les cr√©neaux horaires
app.get('/api/time-slots', async (req, res) => {
  try {
    console.log('üïê R√©cup√©ration des cr√©neaux horaires');
    
    const result = await pool.query(`
      SELECT * FROM time_slots 
      ORDER BY display_order ASC
    `);
    
    console.log('‚úÖ Cr√©neaux horaires r√©cup√©r√©s:', result.rows.length);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration cr√©neaux:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

app.post('/api/time-slots', async (req, res) => {
  try {
    console.log('üïê Cr√©ation d\'un cr√©neau horaire');
    
    const { name, start_time, end_time, duration_minutes, is_available, price, space_id } = req.body;
    
    const result = await pool.query(`
      INSERT INTO time_slots (name, start_time, end_time, duration_minutes, is_available, price, space_id, display_order, created_at, updated_at)
      VALUES ($1, $2, $3, $4, $5, $6, $7, (SELECT COALESCE(MAX(display_order), 0) + 1 FROM time_slots), $8, $9)
      RETURNING *
    `, [name, start_time, end_time, duration_minutes, is_available, price, space_id, new Date().toISOString(), new Date().toISOString()]);
    
    console.log('‚úÖ Cr√©neau horaire cr√©√©');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation cr√©neau:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

app.put('/api/time-slots/:id', async (req, res) => {
  try {
    console.log(`üïê Mise √† jour du cr√©neau horaire: ${req.params.id}`);
    
    const updateData = req.body;
    const timeSlotId = req.params.id;
    
    // Construire la requ√™te de mise √† jour dynamiquement
    const fields = [];
    const values = [];
    let paramIndex = 1;
    
    for (const [key, value] of Object.entries(updateData)) {
      if (key !== 'id' && value !== undefined) {
        fields.push(`${key} = $${paramIndex}`);
        values.push(value);
        paramIndex++;
      }
    }
    
    if (fields.length === 0) {
      return res.status(400).json({ success: false, error: 'Aucune donn√©e √† mettre √† jour' });
    }
    
    // Ajouter updated_at
    fields.push(`updated_at = $${paramIndex}`);
    values.push(new Date().toISOString());
    paramIndex++;
    
    // Ajouter l'ID √† la fin
    values.push(timeSlotId);
    
    const query = `
      UPDATE time_slots 
      SET ${fields.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING *
    `;
    
    const result = await pool.query(query, values);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Cr√©neau horaire non trouv√©' });
    }
    
    console.log('‚úÖ Cr√©neau horaire mis √† jour');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur mise √† jour cr√©neau:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

app.delete('/api/time-slots/:id', async (req, res) => {
  try {
    console.log(`üïê Suppression du cr√©neau horaire: ${req.params.id}`);
    
    const result = await pool.query(`
      DELETE FROM time_slots 
      WHERE id = $1
    `, [req.params.id]);
    
    console.log('‚úÖ Cr√©neau horaire supprim√©');
    res.json({ success: true, message: 'Cr√©neau horaire supprim√© avec succ√®s' });
  } catch (error) {
    console.error('‚ùå Erreur suppression cr√©neau:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

app.put('/api/time-slots/swap-orders', async (req, res) => {
  try {
    console.log('üîÑ √âchange des ordres de cr√©neaux horaires');
    
    const { firstSlotId, firstSlotOrder, secondSlotId, secondSlotOrder } = req.body;
    
    // √âchanger les ordres
    await pool.query(`
      UPDATE time_slots 
      SET display_order = $1, updated_at = $2
      WHERE id = $3
    `, [secondSlotOrder, new Date().toISOString(), firstSlotId]);
    
    await pool.query(`
      UPDATE time_slots 
      SET display_order = $1, updated_at = $2
      WHERE id = $3
    `, [firstSlotOrder, new Date().toISOString(), secondSlotId]);
    
    console.log('‚úÖ Ordres √©chang√©s');
    res.json({ success: true, message: 'Ordres √©chang√©s avec succ√®s' });
  } catch (error) {
    console.error('‚ùå Erreur √©change ordres:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©organiser les images du carrousel
app.put('/api/carousel-images/reorder', async (req, res) => {
  try {
    console.log('üîÑ R√©organisation des images du carrousel');
    
    const { images } = req.body;
    
    if (!images || !Array.isArray(images)) {
      return res.status(400).json({ success: false, error: 'Donn√©es d\'images invalides' });
    }
    
    // Mettre √† jour l'ordre de chaque image
    for (const image of images) {
      await pool.query(`
        UPDATE carousel_images 
        SET display_order = $1, updated_at = $2
        WHERE id = $3
      `, [image.display_order, new Date().toISOString(), image.id]);
    }
    
    console.log('‚úÖ Images r√©organis√©es');
    res.json({ success: true, message: 'Images r√©organis√©es avec succ√®s' });
  } catch (error) {
    console.error('‚ùå Erreur r√©organisation images:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour supprimer un document d'un utilisateur
app.delete('/api/users/:userId/documents/:documentId', async (req, res) => {
  try {
    console.log(`üìÑ Suppression du document: ${req.params.documentId} pour l'utilisateur: ${req.params.userId}`);
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'profile_documents'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('‚ö†Ô∏è Table profile_documents n\'existe pas');
      return res.json({ success: true, message: 'Table n\'existe pas' });
    }
    
    const result = await pool.query(`
      DELETE FROM profile_documents 
      WHERE id = $1 AND user_id = $2
    `, [req.params.documentId, req.params.userId]);
    
    console.log('‚úÖ Document supprim√©');
    res.json({ success: true, message: 'Document supprim√© avec succ√®s' });
  } catch (error) {
    console.error('‚ùå Erreur suppression document:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les param√®tres de l'entreprise
app.get('/api/company-settings', async (req, res) => {
  try {
    console.log('üè¢ R√©cup√©ration des param√®tres de l\'entreprise');
    
    const result = await pool.query(`
      SELECT value FROM admin_settings 
      WHERE key = 'company'
      ORDER BY updated_at DESC
      LIMIT 1
    `);
    
    if (result.rows.length > 0) {
      console.log('‚úÖ Param√®tres entreprise r√©cup√©r√©s');
      res.json({ success: true, data: result.rows[0].value });
    } else {
      console.log('‚ö†Ô∏è Aucun param√®tre entreprise trouv√©, retour de valeurs par d√©faut');
      // Retourner des valeurs par d√©faut
      const defaultCompanySettings = {
        name: "Votre Entreprise",
        email: "contact@votre-entreprise.com",
        phone: "+33 1 23 45 67 89",
        address: "123 Rue de la Paix\n75001 Paris, France",
        website: "https://www.votre-entreprise.com",
        description: "Une entreprise innovante",
        logo_url: "",
        siret: "",
        vat_number: ""
      };
      res.json({ success: true, data: defaultCompanySettings });
    }
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration param√®tres entreprise:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour sauvegarder les param√®tres de l'entreprise
app.post('/api/company-settings', async (req, res) => {
  try {
    console.log('üè¢ Sauvegarde des param√®tres de l\'entreprise');
    
    const companyData = req.body;
    
    const result = await pool.query(`
      INSERT INTO admin_settings (key, value, updated_at)
      VALUES ('company', $1, $2)
      ON CONFLICT (key) 
      DO UPDATE SET 
        value = EXCLUDED.value,
        updated_at = EXCLUDED.updated_at
      RETURNING *
    `, [JSON.stringify(companyData), new Date().toISOString()]);
    
    console.log('‚úÖ Param√®tres entreprise sauvegard√©s');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur sauvegarde param√®tres entreprise:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint de debug pour voir toutes les donn√©es
app.get('/api/debug-homepage', async (req, res) => {
  try {
    const allData = await pool.query(`
      SELECT key, value, updated_at FROM admin_settings 
      ORDER BY updated_at DESC
    `);
    console.log('üîç Toutes les donn√©es admin_settings:', allData.rows);
    res.json({ success: true, data: allData.rows });
  } catch (error) {
    console.error('‚ùå Erreur debug:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les param√®tres homepage
app.get('/api/homepage-settings', async (req, res) => {
  try {
    console.log('üè† R√©cup√©ration des param√®tres homepage...');
    console.log('üè† ENDPOINT GET HOMEPAGE CALLED');
    
    // D'abord, voir toutes les cl√©s disponibles
    const allKeys = await pool.query(`
      SELECT key, updated_at FROM admin_settings 
      ORDER BY updated_at DESC
    `);
    console.log('üîç Toutes les cl√©s disponibles:', allKeys.rows);
    
    // R√©cup√©rer depuis admin_settings avec la cl√© 'homepage'
    const result = await pool.query(`
      SELECT value FROM admin_settings 
      WHERE key = $1
      ORDER BY updated_at DESC 
      LIMIT 1
    `, ['homepage']);
    
    console.log('üîç R√©sultat de la requ√™te:', result.rows);
    console.log('üîç Nombre de lignes trouv√©es:', result.rows.length);
    
    if (result.rows.length === 0) {
      console.log('üè† Aucun param√®tre homepage trouv√©, retour de donn√©es par d√©faut');
      res.json({ 
        success: true, 
        data: {
          title: 'CoWorkMy',
          subtitle: 'Votre espace de coworking',
          description: 'D√©couvrez nos espaces de coworking modernes',
          backgroundImage: 'https://images.unsplash.com/photo-1600508774636-7b8fHx8fGVufDB8fHx8&auto=format&fit=crop&w=1470&q=80'
        }
      });
      return;
    }
    
    console.log('‚úÖ Param√®tres homepage r√©cup√©r√©s:', result.rows[0].value);
    res.json({ success: true, data: result.rows[0].value });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration param√®tres homepage:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour sauvegarder les param√®tres homepage
app.post('/api/homepage-settings', async (req, res) => {
  try {
    console.log('üè† Sauvegarde des param√®tres homepage...');
    
    const settings = req.body;
    
    // Sauvegarder dans admin_settings avec la cl√© 'homepage'
    const result = await pool.query(`
      INSERT INTO admin_settings (key, value, updated_at)
      VALUES ($1, $2, $3)
      ON CONFLICT (key) DO UPDATE SET
        value = EXCLUDED.value,
        updated_at = EXCLUDED.updated_at
      RETURNING *
    `, [
      'homepage',
      JSON.stringify(settings),
      new Date().toISOString()
    ]);
    
    console.log('‚úÖ Param√®tres homepage sauvegard√©s');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur sauvegarde param√®tres homepage:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour sauvegarder les param√®tres admin
app.post('/api/admin/settings', async (req, res) => {
  try {
    console.log('‚öôÔ∏è Sauvegarde des param√®tres admin...');
    
    const settings = req.body;
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'admin_settings'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('‚öôÔ∏è Table admin_settings n\'existe pas, retour de succ√®s simul√©');
      res.json({ success: true, data: settings });
      return;
    }
    
    // Sauvegarder les param√®tres
    const result = await pool.query(`
      INSERT INTO admin_settings (key, value, updated_at)
      VALUES ($1, $2, $3)
      ON CONFLICT (key) DO UPDATE SET
        value = EXCLUDED.value,
        updated_at = EXCLUDED.updated_at
      RETURNING *
    `, [
      settings.key || 'general',
      JSON.stringify(settings.value || settings),
      new Date().toISOString()
    ]);
    
    console.log('‚úÖ Param√®tres admin sauvegard√©s');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur sauvegarde param√®tres admin:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer les images du carrousel
app.get('/api/carousel-images', async (req, res) => {
  try {
    console.log('üñºÔ∏è R√©cup√©ration des images du carrousel...');
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'carousel_images'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üñºÔ∏è Table carousel_images n\'existe pas, retour de donn√©es par d√©faut');
      res.json({ success: true, data: [] });
      return;
    }
    
    // V√©rifier la structure de la table
    const tableInfo = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'carousel_images'
    `);
    
    console.log('üìã Structure de la table carousel_images:', tableInfo.rows);
    
    // Utiliser la structure existante
    const columns = tableInfo.rows.map(row => row.column_name);
    let selectQuery = 'SELECT * FROM carousel_images ORDER BY ';
    
    if (columns.includes('created_at')) {
      selectQuery += 'created_at DESC';
    } else if (columns.includes('id')) {
      selectQuery += 'id DESC';
    } else {
      selectQuery += '1';
    }
    
    const result = await pool.query(selectQuery);
    
    console.log(`‚úÖ ${result.rows.length} images du carrousel r√©cup√©r√©es`);
    res.json({ success: true, data: result.rows });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration images carrousel:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour ajouter une image au carrousel
app.post('/api/carousel-images', async (req, res) => {
  try {
    console.log('üñºÔ∏è Ajout d\'une image au carrousel...');
    
    const { image_url } = req.body;
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'carousel_images'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üñºÔ∏è Table carousel_images n\'existe pas, retour de succ√®s simul√©');
      res.json({ success: true, data: { id: Date.now(), url: image_url } });
      return;
    }
    
    // V√©rifier la structure de la table
    const tableInfo = await pool.query(`
      SELECT column_name, data_type 
      FROM information_schema.columns 
      WHERE table_name = 'carousel_images'
    `);
    
    console.log('üìã Structure de la table carousel_images:', tableInfo.rows);
    
    const columns = tableInfo.rows.map(row => row.column_name);
    
    // Construire la requ√™te d'insertion selon la structure existante
    let insertQuery = 'INSERT INTO carousel_images (';
    let valuesQuery = 'VALUES (';
    let params = [];
    let paramIndex = 1;
    
    if (columns.includes('url')) {
      insertQuery += 'url';
      valuesQuery += `$${paramIndex}`;
      params.push(image_url);
      paramIndex++;
    } else if (columns.includes('image_url')) {
      insertQuery += 'image_url';
      valuesQuery += `$${paramIndex}`;
      params.push(image_url);
      paramIndex++;
    }
    
    if (columns.includes('created_at')) {
      insertQuery += ', created_at';
      valuesQuery += `, $${paramIndex}`;
      params.push(new Date().toISOString());
      paramIndex++;
    }
    
    insertQuery += ') ';
    valuesQuery += ') RETURNING *';
    
    const result = await pool.query(insertQuery + valuesQuery, params);
    
    console.log('‚úÖ Image ajout√©e au carrousel');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur ajout image carrousel:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour supprimer une image du carrousel
app.delete('/api/carousel-images/:id', async (req, res) => {
  try {
    console.log(`üóëÔ∏è Suppression de l'image carrousel: ${req.params.id}`);
    
    // V√©rifier si la table existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_name = 'carousel_images'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üñºÔ∏è Table carousel_images n\'existe pas, retour de succ√®s simul√©');
      res.json({ success: true, data: { id: req.params.id } });
      return;
    }
    
    const result = await pool.query(`
      DELETE FROM carousel_images 
      WHERE id = $1
      RETURNING *
    `, [req.params.id]);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Image non trouv√©e' });
    }
    
    console.log('‚úÖ Image supprim√©e du carrousel');
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur suppression image carrousel:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour cr√©er un espace
app.post('/api/spaces', async (req, res) => {
  try {
    console.log('üè¢ POST /api/spaces - Cr√©ation d\'un espace...');
    console.log('üìù Donn√©es re√ßues:', req.body);
    
    const { name, description, capacity, price_per_hour, is_active } = req.body;
    
    // V√©rifier que la table spaces existe
    const tableExists = await pool.query(`
      SELECT EXISTS (
        SELECT FROM information_schema.tables 
        WHERE table_schema = 'public' 
        AND table_name = 'spaces'
      );
    `);
    
    if (!tableExists.rows[0].exists) {
      console.log('üìã Cr√©ation de la table spaces...');
      await pool.query(`
        CREATE TABLE spaces (
          id SERIAL PRIMARY KEY,
          name VARCHAR(255) NOT NULL,
          description TEXT,
          capacity INTEGER NOT NULL,
          price_per_hour DECIMAL(10,2),
          hourly_price DECIMAL(10,2) DEFAULT 0,
          daily_price DECIMAL(10,2) DEFAULT 0,
          half_day_price DECIMAL(10,2) DEFAULT 0,
          monthly_price DECIMAL(10,2) DEFAULT 0,
          quarter_price DECIMAL(10,2) DEFAULT 0,
          yearly_price DECIMAL(10,2) DEFAULT 0,
          custom_price DECIMAL(10,2) DEFAULT 0,
          custom_label VARCHAR(255),
          pricing_type VARCHAR(50) DEFAULT 'hourly',
          amenities TEXT[],
          image_url TEXT,
          is_active BOOLEAN DEFAULT true,
          created_at TIMESTAMP DEFAULT NOW(),
          updated_at TIMESTAMP DEFAULT NOW()
        );
      `);
      console.log('‚úÖ Table spaces cr√©√©e');
    }
    
    // Ins√©rer l'espace
    const result = await pool.query(`
      INSERT INTO spaces (name, description, capacity, price_per_hour, is_active, created_at, updated_at)
      VALUES ($1, $2, $3, $4, $5, NOW(), NOW())
      RETURNING *
    `, [name, description, capacity, price_per_hour, is_active]);
    
    console.log('‚úÖ Espace cr√©√©:', result.rows[0]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur cr√©ation espace:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour modifier un espace
app.put('/api/spaces/:id', async (req, res) => {
  try {
    console.log('üè¢ PUT /api/spaces/:id - Modification d\'un espace...');
    console.log('üìù ID:', req.params.id);
    console.log('üìù Donn√©es re√ßues:', req.body);
    
    const { id } = req.params;
    const updateData = req.body;
    
    // V√©rifier que l'espace existe
    const existingSpace = await pool.query('SELECT * FROM spaces WHERE id = $1', [id]);
    
    if (existingSpace.rows.length === 0) {
      console.log('‚ùå Espace non trouv√©:', id);
      return res.status(404).json({ success: false, error: 'Espace non trouv√©' });
    }
    
    // Construire la requ√™te de mise √† jour dynamiquement
    const fields = [];
    const values = [];
    let paramIndex = 1;
    
    // Liste des colonnes valides pour la table spaces
    const validColumns = [
      'name', 'description', 'capacity', 'price_per_hour', 'hourly_price', 
      'daily_price', 'half_day_price', 'monthly_price', 'quarter_price', 
      'yearly_price', 'custom_price', 'custom_label', 'pricing_type', 
      'amenities', 'image_url', 'is_active', 'stripe_product_id', 
      'stripe_price_id', 'last_stripe_sync'
    ];
    
    for (const [key, value] of Object.entries(updateData)) {
      if (key !== 'id' && value !== undefined && validColumns.includes(key)) {
        fields.push(`${key} = $${paramIndex}`);
        values.push(value);
        paramIndex++;
      }
    }
    
    if (fields.length === 0) {
      return res.status(400).json({ success: false, error: 'Aucune donn√©e √† mettre √† jour' });
    }
    
    // Ajouter updated_at
    fields.push(`updated_at = $${paramIndex}`);
    values.push(new Date().toISOString());
    paramIndex++;
    
    // Ajouter l'ID √† la fin
    values.push(id);
    
    const query = `
      UPDATE spaces 
      SET ${fields.join(', ')}
      WHERE id = $${paramIndex}
      RETURNING *
    `;
    
    const result = await pool.query(query, values);
    
    console.log('‚úÖ Espace modifi√©:', result.rows[0]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur modification espace:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour r√©cup√©rer un espace sp√©cifique
app.get('/api/spaces/:id', async (req, res) => {
  try {
    console.log('üè¢ GET /api/spaces/:id - R√©cup√©ration d\'un espace...');
    console.log('üìù ID:', req.params.id);
    
    const { id } = req.params;
    
    // R√©cup√©rer l'espace
    const result = await pool.query('SELECT * FROM spaces WHERE id = $1', [id]);
    
    if (result.rows.length === 0) {
      console.log('‚ùå Espace non trouv√©:', id);
      return res.status(404).json({ success: false, error: 'Espace non trouv√©' });
    }
    
    console.log('‚úÖ Espace r√©cup√©r√©:', result.rows[0]);
    res.json({ success: true, data: result.rows[0] });
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration espace:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint pour supprimer un espace
app.delete('/api/spaces/:id', async (req, res) => {
  try {
    console.log('üè¢ DELETE /api/spaces/:id - Suppression d\'un espace...');
    console.log('üìù ID:', req.params.id);
    
    const { id } = req.params;
    
    // V√©rifier que l'espace existe
    const existingSpace = await pool.query('SELECT * FROM spaces WHERE id = $1', [id]);
    
    if (existingSpace.rows.length === 0) {
      console.log('‚ùå Espace non trouv√©:', id);
      return res.status(404).json({ success: false, error: 'Espace non trouv√©' });
    }
    
    // Supprimer l'espace
    await pool.query('DELETE FROM spaces WHERE id = $1', [id]);
    
    console.log('‚úÖ Espace supprim√©:', id);
    res.json({ success: true, message: 'Espace supprim√© avec succ√®s' });
  } catch (error) {
    console.error('‚ùå Erreur suppression espace:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Endpoint de test simple
app.get('/api/test-simple', (req, res) => {
  res.json({ success: true, message: 'API fonctionnelle', timestamp: new Date().toISOString() });
});

// Fonction pour r√©cup√©rer la configuration Stripe
const getStripeConfig = async () => {
  try {
    const result = await pool.query(`
      SELECT value FROM admin_settings 
      WHERE key = 'stripe' 
      ORDER BY updated_at DESC 
      LIMIT 1
    `);
    
    if (result.rows.length === 0) {
      throw new Error('Configuration Stripe non trouv√©e');
    }
    
    // Le value est stock√© comme une cha√Æne JSON, il faut la parser
    const config = typeof result.rows[0].value === 'string' 
      ? JSON.parse(result.rows[0].value) 
      : result.rows[0].value;
    
    console.log('üîß Configuration Stripe r√©cup√©r√©e:', {
      mode: config.mode,
      hasTestSecret: !!config.test_secret_key,
      hasLiveSecret: !!config.live_secret_key
    });
    
    const secretKey = config.mode === 'live' ? config.live_secret_key : config.test_secret_key;
    const publishableKey = config.mode === 'live' ? config.live_publishable_key : config.test_publishable_key;
    const webhookSecret = config.mode === 'live' ? config.live_webhook_secret : config.webhook_secret;
    
    if (!secretKey) {
      throw new Error(`Cl√© secr√®te Stripe manquante pour le mode ${config.mode}`);
    }
    
    return {
      secretKey,
      publishableKey,
      webhookSecret,
      mode: config.mode || 'test'
    };
  } catch (error) {
    console.error('Erreur r√©cup√©ration config Stripe:', error);
    throw error;
  }
};

// Endpoint pour tester la connexion Stripe
app.get('/api/stripe/test-connection', async (req, res) => {
  try {
    console.log('üîó GET /api/stripe/test-connection - Test connexion Stripe...');
    
    const config = await getStripeConfig();
    const stripe = new Stripe(config.secretKey);
    
    // Tester la connexion en r√©cup√©rant le compte
    const account = await stripe.accounts.retrieve();
    
    console.log('‚úÖ Connexion Stripe r√©ussie:', account.id);
    res.json({
      success: true,
      message: 'Connexion Stripe r√©ussie',
      account: {
        id: account.id,
        country: account.country,
        charges_enabled: account.charges_enabled,
        payouts_enabled: account.payouts_enabled,
        details_submitted: account.details_submitted
      },
      mode: config.mode
    });
  } catch (error) {
    console.error('‚ùå Erreur connexion Stripe:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Erreur de connexion √† Stripe'
    });
  }
});

// Endpoint pour synchroniser un espace avec Stripe
app.post('/api/stripe/sync-space/:spaceId', async (req, res) => {
  try {
    console.log('üîÑ POST /api/stripe/sync-space/:spaceId - Synchronisation espace Stripe...');
    console.log('üìù Space ID:', req.params.spaceId);
    
    const { spaceId } = req.params;
    const config = await getStripeConfig();
    const stripe = new Stripe(config.secretKey);
    
    // R√©cup√©rer l'espace depuis la base de donn√©es
    const spaceResult = await pool.query('SELECT * FROM spaces WHERE id = $1', [spaceId]);
    
    if (spaceResult.rows.length === 0) {
      return res.status(404).json({ success: false, error: 'Espace non trouv√©' });
    }
    
    const space = spaceResult.rows[0];
    console.log('üìã Espace trouv√©:', space.name);
    
    // V√©rifier si un produit Stripe existe d√©j√† pour cet espace
    let product;
    if (space.stripe_product_id) {
      try {
        // R√©cup√©rer le produit existant
        product = await stripe.products.retrieve(space.stripe_product_id);
        console.log('‚úÖ Produit Stripe existant trouv√©:', product.id);
      } catch (error) {
        console.log('‚ö†Ô∏è Produit Stripe existant introuvable, cr√©ation d\'un nouveau...');
        product = null;
      }
    }
    
    if (!product) {
      // Cr√©er un nouveau produit Stripe
      product = await stripe.products.create({
        name: space.name,
        description: space.description,
        metadata: {
          space_id: space.id,
          capacity: space.capacity.toString(),
          amenities: JSON.stringify(space.amenities || [])
        }
      });
      console.log('‚úÖ Nouveau produit Stripe cr√©√©:', product.id);
    }
    
    // Cr√©er les prix selon le type de tarification
    const prices = [];
    
    // V√©rifier si un prix existe d√©j√† pour cet espace
    let price = null;
    if (space.stripe_price_id) {
      try {
        // R√©cup√©rer le prix existant
        price = await stripe.prices.retrieve(space.stripe_price_id);
        console.log('‚úÖ Prix existant trouv√©:', price.id);
      } catch (error) {
        console.log('‚ö†Ô∏è Prix existant introuvable, cr√©ation d\'un nouveau...');
        price = null;
      }
    }
    
    if (!price && space.pricing_type === 'hourly' && space.hourly_price > 0) {
      price = await stripe.prices.create({
        product: product.id,
        unit_amount: Math.round(space.hourly_price * 100), // Convertir en centimes
        currency: 'eur',
        metadata: {
          space_id: space.id,
          pricing_type: 'hourly'
        }
      });
      console.log('‚úÖ Nouveau prix cr√©√©:', price.id);
    }
    
    if (price) {
      prices.push({ type: 'hourly', price_id: price.id, amount: space.hourly_price });
    }
    
    if (space.pricing_type === 'daily' && space.daily_price > 0) {
      const price = await stripe.prices.create({
        product: product.id,
        unit_amount: Math.round(space.daily_price * 100),
        currency: 'eur',
        metadata: {
          space_id: space.id,
          pricing_type: 'daily'
        }
      });
      prices.push({ type: 'daily', price_id: price.id, amount: space.daily_price });
    }
    
    if (space.pricing_type === 'monthly' && space.monthly_price > 0) {
      const price = await stripe.prices.create({
        product: product.id,
        unit_amount: Math.round(space.monthly_price * 100),
        currency: 'eur',
        recurring: {
          interval: 'month'
        },
        metadata: {
          space_id: space.id,
          pricing_type: 'monthly'
        }
      });
      prices.push({ type: 'monthly', price_id: price.id, amount: space.monthly_price });
    }
    
    // Mettre √† jour l'espace avec les IDs Stripe
    await pool.query(`
      UPDATE spaces 
      SET stripe_product_id = $1, 
          stripe_price_id = $2,
          last_stripe_sync = NOW(),
          updated_at = NOW()
      WHERE id = $3
    `, [
      product.id,
      prices.length > 0 ? prices[0].price_id : null,
      spaceId
    ]);
    
    console.log('‚úÖ Espace synchronis√© avec Stripe');
    res.json({
      success: true,
      message: `Espace "${space.name}" synchronis√© avec Stripe`,
      data: {
        space_id: space.id,
        stripe_product_id: product.id,
        prices: prices,
        mode: config.mode
      }
    });
  } catch (error) {
    console.error('‚ùå Erreur synchronisation Stripe:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Erreur lors de la synchronisation avec Stripe'
    });
  }
});

// Endpoint pour synchroniser tous les espaces
app.post('/api/stripe/sync-all', async (req, res) => {
  try {
    console.log('üîÑ POST /api/stripe/sync-all - Synchronisation de tous les espaces...');
    
    const config = await getStripeConfig();
    const stripe = new Stripe(config.secretKey);
    
    // R√©cup√©rer tous les espaces actifs
    const spacesResult = await pool.query(`
      SELECT * FROM spaces 
      WHERE is_active = true 
      ORDER BY created_at DESC
    `);
    
    const spaces = spacesResult.rows;
    console.log(`üìã ${spaces.length} espaces √† synchroniser`);
    
    const results = [];
    
    for (const space of spaces) {
      try {
        console.log(`üîÑ Synchronisation: ${space.name}`);
        
        // V√©rifier si un produit Stripe existe d√©j√† pour cet espace
        let product;
        if (space.stripe_product_id) {
          try {
            // R√©cup√©rer le produit existant
            product = await stripe.products.retrieve(space.stripe_product_id);
            console.log(`‚úÖ Produit existant trouv√© pour ${space.name}:`, product.id);
          } catch (error) {
            console.log(`‚ö†Ô∏è Produit existant introuvable pour ${space.name}, cr√©ation d'un nouveau...`);
            product = null;
          }
        }
        
        if (!product) {
          // Cr√©er un nouveau produit Stripe
          product = await stripe.products.create({
            name: space.name,
            description: space.description,
            metadata: {
              space_id: space.id,
              capacity: space.capacity.toString(),
              amenities: JSON.stringify(space.amenities || [])
            }
          });
          console.log(`‚úÖ Nouveau produit cr√©√© pour ${space.name}:`, product.id);
        }
        
        // V√©rifier si un prix existe d√©j√† pour cet espace
        let price = null;
        if (space.stripe_price_id) {
          try {
            // R√©cup√©rer le prix existant
            price = await stripe.prices.retrieve(space.stripe_price_id);
            console.log(`‚úÖ Prix existant trouv√© pour ${space.name}:`, price.id);
          } catch (error) {
            console.log(`‚ö†Ô∏è Prix existant introuvable pour ${space.name}, cr√©ation d'un nouveau...`);
            price = null;
          }
        }
        
        if (!price && space.hourly_price > 0) {
          // Cr√©er un nouveau prix
          price = await stripe.prices.create({
            product: product.id,
            unit_amount: Math.round(space.hourly_price * 100),
            currency: 'eur',
            metadata: {
              space_id: space.id,
              pricing_type: 'hourly'
            }
          });
          console.log(`‚úÖ Nouveau prix cr√©√© pour ${space.name}:`, price.id);
        }
        
        // Mettre √† jour l'espace
        await pool.query(`
          UPDATE spaces 
          SET stripe_product_id = $1, 
              stripe_price_id = $2,
              last_stripe_sync = NOW(),
              updated_at = NOW()
          WHERE id = $3
        `, [product.id, price?.id || null, space.id]);
        
        results.push({
          space_id: space.id,
          space_name: space.name,
          success: true,
          stripe_product_id: product.id,
          stripe_price_id: price?.id || null
        });
        
        console.log(`‚úÖ ${space.name} synchronis√©`);
      } catch (spaceError) {
        console.error(`‚ùå Erreur pour ${space.name}:`, spaceError);
        results.push({
          space_id: space.id,
          space_name: space.name,
          success: false,
          error: spaceError.message
        });
      }
    }
    
    const successCount = results.filter(r => r.success).length;
    const errorCount = results.filter(r => !r.success).length;
    
    console.log(`‚úÖ Synchronisation termin√©e: ${successCount} succ√®s, ${errorCount} erreurs`);
    res.json({
      success: true,
      message: `Synchronisation termin√©e: ${successCount}/${spaces.length} espaces synchronis√©s`,
      data: {
        total: spaces.length,
        success: successCount,
        errors: errorCount,
        results: results,
        mode: config.mode
      }
    });
  } catch (error) {
    console.error('‚ùå Erreur synchronisation globale:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Erreur lors de la synchronisation globale'
    });
  }
});

// Endpoint pour v√©rifier le statut de synchronisation
app.get('/api/stripe/sync-status', async (req, res) => {
  try {
    console.log('üìä GET /api/stripe/sync-status - V√©rification statut synchronisation...');
    
    const config = await getStripeConfig();
    
    // R√©cup√©rer les espaces avec leur statut Stripe
    const spacesResult = await pool.query(`
      SELECT id, name, stripe_product_id, stripe_price_id, last_stripe_sync, is_active
      FROM spaces 
      ORDER BY created_at DESC
    `);
    
    const spaces = spacesResult.rows;
    const syncedSpaces = spaces.filter(s => s.stripe_product_id && s.stripe_price_id);
    const unsyncedSpaces = spaces.filter(s => !s.stripe_product_id || !s.stripe_price_id);
    const activeSpaces = spaces.filter(s => s.is_active);
    
    console.log(`üìä Statut: ${syncedSpaces.length}/${spaces.length} espaces synchronis√©s`);
    res.json({
      success: true,
      data: {
        total: spaces.length,
        active: activeSpaces.length,
        synced: syncedSpaces.length,
        unsynced: unsyncedSpaces.length,
        mode: config.mode,
        spaces: spaces.map(s => ({
          id: s.id,
          name: s.name,
          is_active: s.is_active,
          is_synced: !!(s.stripe_product_id && s.stripe_price_id),
          last_sync: s.last_stripe_sync
        }))
      }
    });
  } catch (error) {
    console.error('‚ùå Erreur v√©rification statut:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Erreur lors de la v√©rification du statut'
    });
  }
});

// Endpoint pour migrer la table spaces
app.post('/api/migrate-spaces', async (req, res) => {
  try {
    console.log('üîÑ POST /api/migrate-spaces - Migration de la table spaces...');
    
    // Ajouter les colonnes de prix
    console.log('‚ûï Ajout des colonnes de prix...');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS hourly_price DECIMAL(10,2) DEFAULT 0');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS daily_price DECIMAL(10,2) DEFAULT 0');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS half_day_price DECIMAL(10,2) DEFAULT 0');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS monthly_price DECIMAL(10,2) DEFAULT 0');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS quarter_price DECIMAL(10,2) DEFAULT 0');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS yearly_price DECIMAL(10,2) DEFAULT 0');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS custom_price DECIMAL(10,2) DEFAULT 0');
    
    // Ajouter les colonnes de configuration
    console.log('‚ûï Ajout des colonnes de configuration...');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS custom_label VARCHAR(255)');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS pricing_type VARCHAR(50) DEFAULT \'hourly\'');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS amenities TEXT[]');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS image_url TEXT');
    
    // Ajouter les colonnes Stripe
    console.log('‚ûï Ajout des colonnes Stripe...');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS stripe_product_id VARCHAR(255)');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS stripe_price_id VARCHAR(255)');
    await pool.query('ALTER TABLE spaces ADD COLUMN IF NOT EXISTS last_stripe_sync TIMESTAMP');
    
    // Mettre √† jour les donn√©es existantes
    console.log('üîÑ Mise √† jour des donn√©es existantes...');
    await pool.query(`
      UPDATE spaces SET 
        hourly_price = COALESCE(price_per_hour, 0),
        daily_price = COALESCE(price_per_hour * 8, 0),
        half_day_price = COALESCE(price_per_hour * 4, 0),
        monthly_price = COALESCE(price_per_hour * 160, 0),
        pricing_type = 'hourly'
      WHERE hourly_price IS NULL OR hourly_price = 0
    `);
    
    console.log('‚úÖ Migration termin√©e avec succ√®s!');
    res.json({ success: true, message: 'Migration termin√©e avec succ√®s' });
  } catch (error) {
    console.error('‚ùå Erreur migration:', error);
    res.status(500).json({ success: false, error: error.message });
  }
});

// Gestion des erreurs
app.use((err, req, res, next) => {
  console.error('Erreur API:', err);
  res.status(500).json({ error: 'Erreur serveur interne' });
});

// D√©marrage du serveur
app.listen(PORT, () => {
  console.log(`üöÄ Serveur API d√©marr√© sur le port ${PORT}`);
  console.log(`üìä Base de donn√©es: ${process.env.DB_NAME || 'coworkmy'}`);
  console.log(`üé´ Syst√®me de tickets de support uniquement`);
});
